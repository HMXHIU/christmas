# Quests & Quest Generator

- A large language model (LLM) takes in inputs (entities such as locations, monsters, items)
- LLM outputs a quest template

## Inputs to Quest Generator

- First perform a redis query on a location (territory, dungeon, etc ...)
- Add additional filters such as factions (such as orcs, goblins, guilds), to limit the quest theme and objective
- `Monster`, `Item`, `Player` entities contain location information in `geohash` format
- The quest should take into account the `geohash` to make it the quest coherent
- NPCs use the same data structure as `Player` (but controlled by the game/agent)

```ts
interface QuestEntities {
  monsters: Monster[];
  items: Item[]; // eg. taverns, etc ...
  players: Player[];
}

interface QuestObjective {
  objective: string; // objective id
  description: string;
  completionItems: [{ item?: string; prop: string; quantity: number }]; // could be a prop (class of items) or a specific item
}

interface QuestTemplate {
  quest: string; // quest id
  name: string;
  description: string;
  entities: QuestEntities;
  objectives: QuestObjective[];
  rewards: {
    items: { prop: string; quantity: number }[];
    lumina: number;
    umbra: number;
  };
  isCompleted: false;
}

function generateQuest(questInputs: QuestEntities): QuestTemplate {
  // Generate a quest using the entities provided using an LLM
}
```

## QuestTemplate vs Quest

- A `QuestTemplate` can be reused to create quests (this reduces the need to keep running LLMs)
- `QuestTemplate`s should not contain specific items/monsters, but props/beasts
- A redis search could be made to check for the required props/beasts
- The `QuestTemplate` is then converted to a `Quest` by replacing the props/beasts with items/monsters

* Problem when quests become invalid (eg. when a faction is changed)

## Claiming Quests

- For now, quests are available to be claimed in taverns
- When a quest is claimed it is removed from the available quests

## Quest Objectives and Completion

- Instead of hooking into the game loop, all objectives are determined by quest items
- To know if a player as completed an objective is as simple as checking if the player has the item
- When the quest is completed, check if the quest completion items exists and remove them from the player, give the player the reward
- [ ] An enpoint to complete the quest, remove quest items, give reward

## Marking Quests Entities on the Map

- [ ] An endpoint takes in quest id, returns POIs

## Faction Specific Quests

- Quests should be faction specific and territory specific, the quest should be related to the faction and location where the territory is located

## Example Quest Template Output

- A quest template is generated by the LLM and should look something like this

```json
{
  "quest": "quest_003",
  "name": "The Goblin King's Crown",
  "description": "The Village Elder has asked you to retrieve the Goblin King's Crown as proof of his defeat.",
  "objectives": [
    {
      "quest": "objective_1",
      "description": "Retrieve the Goblin King's Crown.",
      "completionItems": [{ "item": "item_goblincrown_1", "quantity": 1 }]
    }
  ],
  "entities": {
    "monsters": [{ "monster": "monster_goblin_king" }],
    "items": [
      {
        "item": "item_goblin_crown"
      }
    ],
    // NPCs are no different from players (controlled by an agent)
    "players": [
      {
        "player": "player_village_elder"
      }
    ]
  },
  "dialogues": [
    {
      "entityId": "village_elder",
      "text": "You must retrieve the Goblin King's Crown as proof of his defeat.",
      "triggerOnObjective": "objective_1"
    },
    {
      "entityId": "village_elder",
      "text": "You have brought the crown. The village is safe again!",
      "triggerOnObjective": "objective_1"
    }
  ],
  "rewards": {
    "items": [{ "prop": "potionofhealth", "quantity": 2 }],
    "lumina": 200,
    "umbra": 0
  },
  "isCompleted": false
}
```

Comparisons and Potential Improvements:

Quest States: Many quest systems include multiple states (e.g., available, in progress, completed, failed). Your system only has claimed and completed states. Consider adding more states for better tracking.
Time Limits: Some quest systems include time limits. You could add an optional "expirationTime" field to the QuestTemplate.
Prerequisites: Complex quest systems often have prerequisites (e.g., player level, previous quests completed). This could be added to make quests more progression-oriented.
Branching Quests: Your system is linear. Some advanced quest systems allow for branching narratives based on player choices.
Repeatable Quests: Consider adding a "repeatable" flag for daily or weekly quests.
Quest Chains: Many MMOs have quest chains. You could add a "nextQuest" field to link quests together.
Dynamic Difficulty: Some systems adjust quest difficulty based on player level or party size. This could be incorporated into the LLM generation process.
Instancing: For multiplayer scenarios, you might need to consider how quest objectives are shared or instanced between players.
Quest Log: While not part of the generation system, a quest log for players to track their active quests would be useful.
Partial Completion: Your system seems to only allow for full completion. Consider allowing partial completion for multi-item objectives.
Faction Reputation: Many quest systems tie into a faction reputation system. This could be added to the rewards.

Things to Consider:

Performance: Using an LLM for quest generation could be computationally expensive. Consider caching generated quests or generating them offline.
Consistency: Ensure the LLM generates consistent and balanced quests. You might need a validation step or human oversight.
Scalability: As your game grows, make sure your quest system can handle a large number of quests and players.
Persistence: Consider how you'll store active quests and player progress, especially for long-term quests.
Testing: Develop a robust testing system to ensure generated quests are always completable and make sense in the game context.

## Quest Template Validation

Prompt: "Output the quest template in valid JSON format using the following validation"

```ts
import { z } from "zod";

const QuestObjectiveSchema = z.object({
  objective: z.string(),
  description: z.string(),
  completionItems: z.array(
    z.object({
      item: z.string().optional(),
      prop: z.string(),
      quantity: z.number(),
    })
  ),
});

const QuestTemplateSchema = z.object({
  quest: z.string(),
  name: z.string(),
  description: z.string(),
  objectives: z.array(QuestObjectiveSchema),
  entities: z.object({
    monsters: z.array(z.object({ monster: z.string() })),
    items: z.array(z.object({ item: z.string() })),
    players: z.array(z.object({ player: z.string() })),
  }),
  dialogues: z.array(
    z.object({
      entityId: z.string(),
      text: z.string(),
      triggerOnObjective: z.string(),
    })
  ),
  rewards: z.object({
    items: z.array(z.object({ prop: z.string(), quantity: z.number() })),
    lumina: z.number(),
    umbra: z.number(),
  }),
  isCompleted: z.boolean(),
});

function validateQuestTemplate(questTemplate: unknown): QuestTemplate {
  return QuestTemplateSchema.parse(questTemplate);
}
```

## Error Handling and Retrie

Implement a retry mechanism if the LLM output fails validation.
You could adjust the prompt or provide more context on retry attempts.

```ts
async function generateValidQuest(
  questInputs: QuestEntities,
  maxRetries = 3
): Promise<QuestTemplate> {
  for (let i = 0; i < maxRetries; i++) {
    try {
      const rawQuestTemplate = await generateQuest(questInputs);
      return validateQuestTemplate(rawQuestTemplate);
    } catch (error) {
      console.error(`Attempt ${i + 1} failed: ${error}`);
      if (i === maxRetries - 1) throw error;
    }
  }
  throw new Error("Failed to generate a valid quest template");
}
```
